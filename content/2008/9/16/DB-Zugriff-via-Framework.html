+++
title = "DB-Zugriff via Framework"
date = "2008-09-16T10:09:00"
author = "Dr. Azrael Tod"
issoid = "blog/734"
aliases = "blog/734"
+++

<p>DB-Zugriff via Framework</p>
<p>Ich habe es bei mehreren Frameworks und APIs schon bemerkt, sei es bei den mitgelieferten Datenobjekten bei <a href="http://de.wikipedia.org/wiki/.NET" target="_blank">.Net</a>, oder sei es bei <a href="http://de.wikipedia.org/wiki/Php" target="_blank">PHP</a> und diversen <a href="http://de.wikipedia.org/wiki/Framework" target="_blank">Frameworks</a> wie <a href="http://de.wikipedia.org/wiki/Symfony" target="_blank">Symfony.</a> (in diesem Fall ist dann wohl eher <a href="http://de.wikipedia.org/wiki/Propel" target="_blank">Propel</a> schuld)<br/>&Uuml;berall existieren Wrapper f&uuml;r den Datenbankzugriff die alles so sch&ouml;n erleichtern sollen. Sie fangen Angriffe via <a href="http://de.wikipedia.org/wiki/SQL-Injection" target="_blank">SQL-Injection</a> ab. Sie lassen uns eine Abfrage in 2 Zeilen schreiben. Sie vereinheitlichen den Zugriff auf die verschiedensten Datenbanken.<!--more--></p>
<p>Ein Problem bekomme ich jedoch oft mit der Flexibilit&auml;t, wenn man z.B. eine sehr Umfangreiche Tabelle mit 50 Spalten hat... (ja ich wei&szlig; dass man sowas nicht tun soll, aber das kommt nunmal vor, man muss es ja nicht selbst verschuldet haben) Nun m&ouml;chte man je nach Abfrage mal die komplette Tabelle f&uuml;r 10 Eintr&auml;ge oder doch nur ID und Name &uuml;ber die ersten 3k Zeilen erhalten, die wenigsten DB-APIs sind auf einen derartigen Fall jedoch eingestellt.<br/>Besonders toll war dieser Fall mit .Net, dort mussten wir bei unserem letzten Versuch f&uuml;r jede andere Spaltenauswahl eine neue Funktion in diesem Datenbankobjekt schreiben. Es war nicht m&ouml;glich die alten einfach anzupassen.<br/>Ich habe mir das Ganze etwa 1-2x angetan, dann bin ich wieder zu reinem SQL gewechselt und habe die Datenbank von Hand aufgerufen. Wir hatten am Ende also zwei komplett unterschiedliche Arten auf die Datenbank zuzugreifen im Projekt, eine schlechter als die andere implementiert. (Das betroffene Projekt war eh nicht gerade das tollste.)<br/>Bei Propel/Symfony bin ich gestern wieder mit einem derartigen System kolidiert, auch wenn dort die Probleme bei weitem nicht so schlimm waren, war ich doch gezwungen meine Eigenen Funktionen zu realisieren.<br/>Symfony generiert anhand einer Datenbankbeschreibung schlicht die Zugriffsfunktionen f&uuml;r so ziemlich jede m&ouml;gliche Datenbankabfrage. Man kann ein Auswahlkriterium f&uuml;r die WHERE-Klausel als Objekt zusammenstellen und &uuml;bergibt dieses Objekt dann einer Funktion al&aacute; Tabelle::doSelect(Criteria).<br/>Probleme treten auf, wenn man versucht mit Joins zu arbeiten. Symfony stellt direkt Funktionen f&uuml;r alle angegebenen M&ouml;glichkeiten die Tabelle mit einer anderen zu joinen bereit (Tabelle::doSelectJoin...), auch stehen Funktionen bereit um Alle m&ouml;glichen Joins bereit zu stellen (doSelectJoinAll). Was jedoch nicht zur Verf&uuml;gung steht sind Funktionen mit denen man von z.B. 10 M&ouml;glichen Joins auf diese Tabelle nur 2 oder 3 bestimmte ausf&uuml;hrt (9 geht wieder: doSelectJoinAllExcept).<br/>Symfony hat jedoch im Gegensatz zu anderen Systemen an dieser Stelle den Vorteil dass es sich relativ schnell dazu bewegen l&auml;sst soetwas doch zu tun.<br/>Man leitet einfach in der Klasse f&uuml;r diese Tabelle eine neue Funktion ab. (Die Klassen sind extra daf&uuml;r in 3 Dateien unterteilt, um die Datenbankstruktur auch bei selbsterstellten Funktionalit&auml;ten noch automatisiert aktuell halten zu k&ouml;nnen.)<br/>Das Ganze macht sich in wenigen Minuten wenn man einmal verstanden hat wie es funktioniert und ist dann auch ziemlich flexibel. Einzig die Dokumentation zu dieser M&ouml;glichkeit fehlt nahezu komplett aber da in einem Unterverzeichnis der komplette generierte Code liegt (der &uuml;brigens grauenvoll aussieht), kann man ja schnell mal nachsehen was man tun m&uuml;sste.<br/>Propel ist also definitiv einen Schritt weiter als die damals von mir getestete Version von .Net. Beide Systeme haben jedoch noch grobe Designfehler, die sie bei komplexeren Anforderungen etwas beh&auml;big machen. Propel gleicht das, etwas umst&auml;ndlich zwar aber doch recht leicht zu verwenden, wieder aus.<br/>.Net jedoch schien diese Fehler einfach als unumg&auml;nglich hinzunehmen. Wahrscheinlich hatte man sich dort auch vom reinen Design etwas verrannt.<br/>Wahrscheinlich m&uuml;ssen wir auf das ultimative Abfragesystem noch eine Weile warten.<br/>(Oder habt ihr es bereits gefunden? Dann bitte eine Anmerkung in den Kommentaren hinterlassen!)</p>
