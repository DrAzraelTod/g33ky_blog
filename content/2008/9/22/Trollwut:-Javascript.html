+++
title = "Trollwut: Javascript"
date = "2008-09-22T11:09:00"
author = "Dr. Azrael Tod"
issoid = "blog/774"
aliases = "blog/774"
+++

<p>Freitag bemerkte ich mal wieder wie froh ich bisher sein konnte so wenig mit Javascript zu tun gehabt zu haben. Ausgangslage war die Einbindung zweier etwas gr&ouml;&szlig;erer JS-Dateien in eine Seite, die ihrerseits wieder alle M&ouml;glichen Daten per Ajax einbanden. Die Ursprungsversion sah also ziemlich so aus wie man es erwarten w&uuml;rde.</p>
<p><code><br/>&lt;script src="http://url.1" /&gt;<br/>&lt;script src="http://url.2" /&gt;<br/>&lt;body onload="run()"&gt;<br/></code><br/>Das hat so eigentlich funktioniert (auch wenn ich einige Zeit f&uuml;r die ganzen Einstellungen in run() ben&ouml;tigte) und zeigte eine eingebundene JS-Applikation sofort nach dem Laden an. Zus&auml;tzlich gab es noch einen einfachen Link auf die JS-Anwendung in einem neuem Fenster mit den wichtigsten Parametern in der URL.<!--more--><br/>Leider war die Anwendung etwas Umfangreicher und verlangsamte die Seite ziemlich drastisch. Also zur&uuml;ck an die Tastatur und eine zweite Version erstellt. Wieder dauerte es eine Weile die Anpassungen vorzunehmen, immerhin musste ein mehrfaches aufrufen von run() verhindert werden, als einfachste Methode erwies es sich einfach als erstes in run() das Objekt mit der ID blah zu verstecken.</p>
<p><code><br/>&lt;script src="http://url.net/1" /&gt;<br/>&lt;script src="http://url.net/2" /&gt;<br/>&lt;p id="blah"&gt;<br/>&lt;a href="#" onload="run()"&gt;start me up!&lt;/a&gt;<br/>&lt;/p&gt;<br/></code></p>
<p>Auch diese Variante funktionierte problemlos, auch war sie um ca. die H&auml;lfte schneller als die vorherige Version und rief die JS-Anwendung erst auf wenn sie von jemandem ben&ouml;tigt wurde. Leider wurden die Javascript-Dateien noch beim Aufruf der Seite geladen, was aufgrund ihrer Gr&ouml;&szlig;e noch immer weit &uuml;ber die H&auml;lfte der Ladezeit insgesammt ausmachte.<br/>Also musste ich versuchen auch diese beiden Dateien bei Bedarf nachzuladen.<br/>Mit Snookies Hilfe war dann auch relativ schnell eine etwas geschicktere L&ouml;sung gefunden. <a href="http://www.javascriptkit.com/javatutors/loadjavascriptcss.shtml" rel="nofollow">http://www.javascriptk...</a><br/>Woraus sich folgender Code ergab:</p>
<p><code><br/>&lt;script type='text/javascript'&gt;<br/>function load()<br/>{<br/>loadjsfile('http://url.net/1');<br/>loadjsfile('http://url.net/2');<br/>run();<br/>}</code></p>
<p>function loadjsfile(filename)<br/>{<br/>var fileref=document.createElement('script')<br/>fileref.setAttribute('type','text/javascript')<br/>fileref.setAttribute('src', filename)<br/>document.getElementsByTagName('head')[0].appendChild(fileref)<br/>}<br/>&lt;/script&gt;<br/>&lt;p id="blah"&gt;<br/><code> </code> &lt;a href="#" onload="load()"&gt;start me up!&lt;/a&gt;<br/>&lt;/p&gt;</p>
<p>Das Problem an dieser L&ouml;sung war aber dass die run()-Funktion nun aufgerufen wurde bevor die beiden js-Dateien fertig herunter geladen waren. Beinahe h&auml;tte ich zu der einfachsten L&ouml;sung gegriffen, "run()" durch setTimeout('run()', 1000) ersetzt und den Nutzer halt einfach 10s warten lassen. Wenn die Dateien in 10s nicht fertig geladen waren (Modem?) h&auml;tte es dieser Idiot halt mit der Alternativversion im neuen Fenster versuchen sollen oder k&ouml;nnte einfach nochmal klicken.<br/>Da ich aber doch um einen (wenigstens etwas) besseren Code bem&uuml;ht war schrieb ich den Code zu folgender Version um:</p>
<p><code><br/>&lt;script type='text/javascript'&gt;<br/>function teil1()<br/>{<br/></code><code> </code><code> var fileref=document.createElement('script')<br/></code><code> </code><code> fileref.setAttribute('type','text/javascript')<br/></code><code> </code><code> fileref.setAttribute('onload','teil2();')<br/></code><code> </code><code> fileref.setAttribute('src', 'http://url.net/1')<br/>}</code></p>
<p>function teil2()<br/>{<br/><code> </code> var fileref=document.createElement('script')<br/><code> </code> fileref.setAttribute('type','text/javascript')<br/><code> </code> fileref.setAttribute('onload','run();')<br/><code> </code> fileref.setAttribute('src', 'http://url.net/2')<br/><code> </code> document.getElementsByTagName('head')[0].appendChild(fileref)<br/>}<br/>&lt;/script&gt;<br/>&lt;p id="blah"&gt;<br/><code> </code> &lt;a href="#" onload="teil1()"&gt;start me up!&lt;/a&gt;<br/>&lt;/p&gt;</p>
<p>Das war nun aber wirklich eine Version mit der man zufrieden sein k&ouml;nnte, die Dateien werden auf Klick geladen und formsch&ouml;n im Quellcode eingebaut, sobald die erste Datei fertig ist wird die zweite in Angriff genommen und nach deren Vollendung auch die JS-Anwendung aufgerufen und der Link zum Aufruf versteckt.<br/>Sicher der Code war etwas l&auml;nger geworden (Erinnert sich noch wer an die 3 Zeilen vom Anfang?), aber was solls? Hauptsache der Code funktioniert und das tat er ja auch... im Firefox.<br/>Internet Exploder jedoch machte keinerlei Anstallten die Zweite Datei einzubinden oder gar run() auszuf&uuml;hren. Nach etwas l&auml;ngerer Recherche war dann auch klar warum. IE unterst&uuml;tzt kein onload in Script-Tags.<br/>Also musste ich meinen Quellcode erneut umstellen und wieder entschied ich mich gegen die einfachste Version (ich teste solange in einer Schleife ob die Dateien geladen sind bis ich true bekomme) zu gunsten der CPU-Auslastung.</p>
<p><code><br/>&lt;script type='text/javascript'&gt;<br/>function load()<br/>{</code></p>
<p><code> </code>loadjsfile('http://url.net/1');<br/><code> </code> loadjsfile('http://url.net/2');<br/><code> </code> versuchs();<br/>}</p>
<p>function loadjsfile(filename)<br/>{<br/><code> </code> var fileref=document.createElement('script')<br/><code> </code> fileref.setAttribute('type','text/javascript')<br/><code> </code> fileref.setAttribute('src', filename)<br/><code> </code> fileref.setAttribute('onload', 'versuchs()')<br/><code> </code> document.getElementsByTagName('head')[0].appendChild(fileref)<br/>}</p>
<p>function versuchs()<br/>{<br/><code> </code> if(typeof(OpenLayers)!= 'undefined' &amp;&amp; typeof(OpenLayers.Layer.OSM)!= 'undefined')<br/><code> </code> {<br/><code> </code><code> </code> init();<br/><code> </code>}<br/><code> </code>else<br/><code> </code>{<br/><code> </code><code> </code>setTimeout('versuchs();',100)<br/><code> </code>}<br/>}<br/>&lt;/script&gt;<br/>&lt;p id="blah"&gt;<br/><code> </code>&lt;a href="#" onload="load()"&gt;start me up!&lt;/a&gt;<br/>&lt;/p&gt;</p>
<p>Ja dieser Code funktioniert. Er tut nichts anderes als eine bereits programmierte Anwendung (deren Startcode bereits in 2 Dateien geliefert wird) aufzurufen. Dabei ist weder die Bereitstellung der Parameter, die Configuration der Anwendung und ihres Aussehens noch irgendwelches andere Zeug enthalten. Nichteinmal das Verstecken des Startlinks ist hier mit notiert.<br/>Dennoch sind aus den anf&auml;nglichen 3 Zeilen mal eben reichlich 30 Zeilen, mit 3 Funktionen und allen m&ouml;glichen Umgehungen von browserspezifischen Problemen, geworden. Ich habe mehrere Stunden mit der Findung eines L&ouml;sung dieses Problemes zugebracht und bin beinahe an den verschiedenen Browserverhaltensweisen verzweifelt.<br/>Was ich damit sagen will: es wird schwer eine einfachere Aufgabe zu finden die man mit Javascript l&ouml;sen muss und dennoch flie&szlig;t eine Unmenge Energie und Aufwand in solchen derartig schlechten Code der nichtmal irgendwelche Erfahrungswerte auf irgendeinem Gebiet au&szlig;er "mit Javascript und Browsern umgehen" bringt.</p>
<p>Das Ziel einer Programmiersprache ist meiner Meinung nach schon immer einem menschlichen Programmierer zu erm&ouml;glichen dem Computer auf dem einfachsten Wege mitzuteilen was er tun soll. Die Aufgabe von Javascript ist aber vielmehr dem Programmierer Wege finden zu lassen wie er die vielen verschiedenen Hindernisse umgeht, die ihm die Browserentwickler in den Weg werfen.<br/>Auch wenn manche total begeistert von Javascript sind, f&uuml;r mich ist und bleibt diese Sprache v&ouml;llig unbrauchbar. Sie ist umst&auml;ndlich, langsam, muss f&uuml;r jede zus&auml;tzliche Zielplatform komplett angepasst werden und erzeugt nichts so sehr wie Agressionen.</p>
<p>Nat&uuml;rlich ist die Situation auf diesem Gebiet bereits besser geworden, die Browserhersteller n&auml;hern sich einander an, die Ausf&uuml;hrung wird &uuml;ber Precompiler beschleunigt (zumindest wird das wohl jetzt gro&szlig;fl&auml;chig kommen) und Bibliotheken ebnen die restlichen Abst&auml;nde und Unterschiede zwischen den Platformen ein.<br/>Dennoch ist die Sprache imho "broken by design", sie zeigte sch&ouml;ne Ans&auml;tze aber das Ziel wurde verfehlt. Bastelt nicht weiter daran herum sondern definiert euch lieber eine komplett neue Sprache bei der ihr die guten Ans&auml;tze verwendet und die L&uuml;cken (wie zu ungenaue Definition des "Standards") vermeidet!</p>
