+++
title = "dynamisch Objekte und Funktionen einbinden in Python"
date = "2008-10-17T01:10:00"
author = "Dr. Azrael Tod"
issoid = "blog/956"
aliases = "blog/956"
+++

<p>Heute mal wieder eine etwas detailiertere Beschreibung wie ich eine Aufgabe in Python gel&ouml;st habe. Das Problem stammt nat&uuml;rlich aus dem <a href="http://code.google.com/p/pychao/" target="_blank">pyChao-IRC-Bot</a>.<br/>Die Problemstellung selbst, war einerseits ein Pluginsystem f&uuml;r einen Parser zu schreiben, das relativ dynamisch Funktionen zu Schl&uuml;sselw&ouml;rtern mapt. Im zweiten Teil werden dann noch dynamisch Funktionen angelegt, um  zus&auml;tzliche Parameter &uuml;bergeben zu k&ouml;nnen.<!--more--><br/></p><h2>Teil 1 - Die allgemeine Registrierung von Befehlen und Modulen:</h2><br/>Wir speichern die Befehle also via key-value-Paaren. In der Initialisierung werden daher erstmal alle Module eingebunden und Instanzen angelegt:<br/><code><span><br/>def import_modules():<br/>&nbsp;&nbsp;&nbsp;&nbsp;cfg = config['modules']<br/>&nbsp;&nbsp;&nbsp;&nbsp;for mod in cfg:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempMod = __import__(cfg[mod]['file'],)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempInst = getattr(<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempMod, cfg[mod]['class']<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)(self,cfg[mod]['config'])<br/></span></code><br/>"__import__('datei')" tut dabei grob gesagt das gleiche wie "import datei", nur dass man durch den Funktionscharacter Strings &uuml;bergeben kann.<br/>Die Funktion "getattr(a,b)" ruft danach Objekt "a.b" als eigenschaft auf, da wir ja vorher nicht wissen wie die Hauptklasse in den Modulen benannt sind, ist dies n&ouml;tig.<br/>dieses Objekt wird dann mit den Parametern "(self,cfg[mod]['config'])" als Parameter instantiiert. Sprich es wird "tempInst" eine neue Instanz des Objektes zugewiesen und in jenem Objekt die Funktion "Objekt.__init__(self,cfg[mod]['config'])" aufgerufen.<br/>Self liefert hierbei eine Referenz auf die Parser-Instanz um wichtige Funktionen dieser innerhalb des Modules aufrufen zu k&ouml;nnen.<br/>Nat&uuml;rlich w&auml;re es auch m&ouml;glich im Modul eine normale Funktion aufzurufen und statt des Klassennamens die Funktion selbst dann aufzurufen. Es kommt halt nur darauf an was man in der Konfigurationsdatei eintr&auml;gt.

<p>Im Modul selbst kann das Ganze dann etwa so aussehen:<br/><code><span><br/>class mod_ruffunktionen:<br/>&nbsp;&nbsp;&nbsp;&nbsp;def __init__(self, parent,config):<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.config = config<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent.register_callback('!rufmich',self.rufmich_cmd)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent.register_callback('!rufihn',self.rufihn_cmd)<br/>&nbsp;&nbsp;&nbsp;&nbsp;def rufmich(parameter):<br/></span></code><br/>Die Funktion "register_callback" wird also f&uuml;r jedes zu verankernde Kommando aufgerufen und ihr wird das Schl&uuml;sselwort und die Funktion &uuml;bergeben.<br/>"register_callback" liegt nat&uuml;rlich wieder im Hauptobjekt des Parsers und sieht folgenderma&szlig;en aus:<br/><code><span><br/>def register_callback(command,callback):<br/>&nbsp;&nbsp;&nbsp;&nbsp;if not self.commands.has_key(command):<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.commands[command] = [callback, helptext]<br/></span></code><br/>Nachdem dann irgendwann die Initialisierung komplett durchgelaufen ist, f&auml;ngt der Parser an zu arbeiten. Bei jedem eingegebenen Kommando wird folgende Funktion aufgerufen:<br/><code><span><br/>def parse_cmd(params):<br/>&nbsp;&nbsp;&nbsp;&nbsp;if self.commands.has_key(params.command):<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.commands[params.command](params)<br/></span></code><br/>Wenn also das Kommando in params "!rufmich" lautet, wird der Parser feststellen dass er die Funktion "rufmich(parameter)" einer mod_ruffunktionen-Instanz aufrufen soll. Es besteht nat&uuml;rlich keinerlei Referenz zu dieser Klasseninstanz, aber in self.commands['!rufmich'] liegt ja der direkte Zeiger auf die Funktion, also brauchen wir das auch &uuml;berhaupt nicht.<br/></p><h2>Teil 2 - dynamische Funktionen erstellen und einbinden</h2><br/>Jetzt haben wir also ein Verzeichniss in dem immer sch&ouml;n Funktionen registriert werden k&ouml;nnen und von dem aus diese Funktionen alle mit den gleichen, genormten Parametern aufgerufen werden k&ouml;nnen.<br/>Doch was machen wir wenn wir eine Funktion haben die gerne noch zus&auml;tzliche Daten &uuml;bergeben haben m&ouml;chte?

<p>Dieses Problem stellte sich z.B. als ich die Kommandos f&uuml;r Newsfeeds realisierte. Im entsprechenden Modul gab es eine Funktion "lese_newsfeed(url, parameter)". Parameter ist wieder die selbe Parameter-Klasse wie wir sie die ganze Zeit verwendet haben, doch was machen wir mit url?<br/>Wir k&ouml;nnten nat&uuml;rlich f&uuml;r jeden eingebundenen Newsfeed eine eigene Funktion schreiben und in der Registry verankern:<br/><code><span><br/>def newsfeed_test(params):<br/>&nbsp;&nbsp;&nbsp;&nbsp;lese_newsfeed('http://test-url',params)<br/></span></code><br/>Nicht gerade sehr flexibel oder?</p>
<p>Besser wird es, wenn wir uns dynamisch Funktionen erzeugen lassen. Dazu brauchen wir erstmal eine Funktion die uns als Factory dient und solche Funktionen nach diesem Schema liefert.</p>
<p><code><span><br/>def rss_factory(url):<br/>&nbsp;&nbsp;&nbsp;&nbsp;prss = lese_newsfeed<br/>&nbsp;&nbsp;&nbsp;&nbsp;def rss_func(params):<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prss(params, url)<br/>&nbsp;&nbsp;&nbsp;&nbsp;return rss_func<br/></span></code><br/>Wir lassen uns also einfach eine Funktion erzeugen, die weniger Parameter hat und geben ihr die restlichen Parameter etwas indirekter mit. Diese Funktion k&ouml;nnen wir uns dann einfach zur&uuml;ckliefern lassen und z.B. in einer Schleife, mit einem passenden Schl&uuml;sselwort registrieren.<br/>Die __init__ des Moduls sieht dann also etwa so aus:<br/><code><span><br/>def __init__(self,parent,config):<br/>&nbsp;&nbsp;&nbsp;&nbsp;for key in config['feeds'].keys():<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent.register_callback('!%s'%key,self.rss_factory(config['feeds'][key]))<br/></span></code></p>
<p>Wir k&ouml;nnen nun beliebig viele Newsfeeds mit key-value in die Konfiguration eintragen und erhalten dynamisch Funktionen f&uuml;r jedes Schl&uuml;sselwort in unserem Parser.</p>
<div class="old_comments"><h3>Importierte/Alte Kommentare:</h3>
<p class="infos">
<a href="#comment_763" onclick="set_comment_reference(763)" title="auf diesen Kommentar antworten">#763</a>:
    17.Oct.2008 01:10
    von
    
      <a href="/blog/author/Dr_Azrael_Tod/">
        Dr. Azrael Tod
      </a>
</p>
<p>Solltet ihr die Version mit fehlender Formatierung vor die Nase geknallt bekommen haben, bitte ich um Verzeihung.<br/>
Wordpress wirft gerne Leerzeichen und &auml;hnliches raus, auch wenn man die im Qu&auml;hlcode explizit angegeben hat. Besonders wenn man seinen verbrochenen Code noch einmal ansehen m&ouml;chte bevor man ihn absendet.</p>
</div>