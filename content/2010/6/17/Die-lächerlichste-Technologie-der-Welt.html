+++
title = "Die l√§cherlichste Technologie der Welt"
date = "2010-06-17T08:06:00"
author = "Dr. Azrael Tod"
tags = ["PC", "Softwareschrott", "Technik"]
issoid = "blog/1525"
aliases = "blog/1525"
+++

<p>Eng zusammenh&auml;ngend mit <a href="http://www.g33ky.de/2010/6/14/Softwareschrott:-string-parsing/">meinem letzten Beitrag zum Thema string-parsing</a>, muss ich heute schon wieder einen rant von mir geben. Diesmal geht es (wie bereits im Titel stehend) um: <b>Die l&auml;cherlichste Technologie der Welt...</b></p>
<p>...ist das WWW wie wir es heutzutage kennen. Besser noch: all die Dinge die sich Web2.0 schimpfen.</p>
<p>Es f&auml;ngt eigentlich noch relativ harmlos an. Ein St&uuml;ck Software erfasst eine Reihe von Eingabefeldern, wertet sie aus und erstellt daraus eine Internetadresse mit Parametern. Sie generiert also einen String wie "http://www.php-seite.com:80/search?q=foo%20bar&amp;do=fuck%you".<br/>Da dem Nutzer das nat&uuml;rlich bis hier her, verdammt wenig gebracht hat, werden die Teile dieser Adresse weiterverwendet (die positive Variante w&auml;re dass die Teile noch vorhanden sind, aber realistisch ist wohl eher dass das selbe St&uuml;ck Software intern den String an eine andere Funktion schickt und die diesen wieder parst).</p>
<p>Also wird (nach diversem Parsen, aufl&ouml;sen von Domainnamen und dem verpacken der Daten in Netzwerkpakete) wieder ein String vom Browser generiert und an einen anderen Rechner gesendet. Das sieht dann vlt so aus: <q><code>GET /search?q=foo%20bar&amp;do=fuck%you HTTP/1.0</code></q><br/>Zus&auml;tzlich werden wohl noch einige weiteren Zeilen gesendet, in denen dann z.B. steht dass man von "http://www.php-seite.com/search" kommt und den Browser "I am a fucking stupid Browser (Version 0.01 pre pre Alpha)" verwendet, aber grunds&auml;tzlich reicht das auch erstmal f&uuml;r unsere Zwecke.</p>
<p>Mit also diesem Text konfrontiert, f&auml;ngt wieder ein anderes St&uuml;ck Software an zu r&ouml;deln und parst diesen String. Wer ist da? Was will er? Wie will er es? Was muss ich in welches Log schreiben? (OK, daf&uuml;r fehlen momentan noch Daten.)<br/>Also stellt es fest dass die datei "search" aus dem Wurzelverzeichniss geholt werden sollte. Nach einem kurzen Blick auf die Festplatte (*r&ouml;del*, gut dass es nicht im 10. Unterverzeichniss lag und erstmal f&uuml;r jedes Elternverzeichniss eine Datei namens .htaccess gesucht, gelesen und geparst werden musste), stellt er fest dass alles unter /search aber eigentlich auf /lib/search_function.php umgeleitet werden soll.</p>
<p>Weil aber search_function.php ein PHP-Script zu sein scheint, stellt unser zweites St&uuml;ck Software fest dass es eigentlich nicht zust&auml;ndig ist und reicht es an ein drittes weiter, dem es einfach diese Datei und die vollst&auml;ndigen Parameter der Anfrage zum Parsen in die Hand dr&uuml;ckt.</p>
<p>Dieses dritte Ding, f&auml;ngt also an die Adresse noch ein weiteres Mal zu zerlegen und bereitet ein paar hundert Variablen vor, mit denen in der Hand es dann mal anf&auml;ngt zu interpretieren was in der Datei so rumliegt. In der Anfrage selbst, bemerkt es dann vlt. noch zus&auml;tzlich dass Softwarest&uuml;ck #1 bereits mehrere Anfragen in Folge gestartet hat und das wahrscheinlich alles irgendwie zusammengeh&ouml;rt.</p>
<p>Bis hierher war der ganze Vorgang evtl. &uuml;berkomplex, sinnlos und defekt, aber ab jetzt wird es wirklich &uuml;bergeschnappt...</p>
<p>Unser St&uuml;ck Software #3 liest also dass noch ein gutes Dutzend weiterer Dateien gebraucht werden, holt sich auch diese von der Festplatte, rechnet noch etwas rum, parst noch mehr Text und erstellt dann zu guter letzt einen neuen String. Der k&ouml;nnte dann vlt. so aussehen: <q><code>"SELECT * FROM `foobar` WHERE `text` LIKE '%foo%' and `text` LIKE '%bar%'</code></q> (Zugegeben, das ist evtl. etwas unfair, eine Suche w&uuml;rde vlt. eher &uuml;ber eine spezielle Volltextsuchengine laufen, aber es gibt ja genug andere F&auml;lle)</p>
<p>Jetzt haben wir also wieder einen String und den reicht #3 an Codehaufen #4 weiter. Dieser (wie sollte es anders sein?) parst diesen String wieder, sucht im RAM und auf der Festplatte und wirft ein paar Daten in einen String den dann Nummer #3 wieder parsen darf.<br/>Das Spiel wiederholen #3 und #4 vlt. noch ein paar dutzend (ich habe auch schon &gt;&gt;100 erlebt) mal und irgendwann f&auml;ngt #3 dann an einen weiteren, wahrscheinlich erheblich komplexeren String zusammen zu bauen (z.B. irgendwas mit "</p>Diesen Text gibt #3 dann an #2 zur&uuml;ck, kappt die Verbindung zu #4 und legt sich wieder schlafen.

<p>#2 sucht noch schnell in ein paar zus&auml;tzlichen Daten von #3, schreibt diese zusammen mit einer groben &Uuml;bersicht &uuml;ber die urspr&uuml;ngliche Anfrage auf die Festplatte (Log) und liefert den langen String zur&uuml;ck &uuml;ber das Netzwerk an #1.</p>
<p>Bereit f&uuml;r noch eine Steigerung dieses Irrsinns?</p>
<p>Nat&uuml;rlich f&auml;ngt der Browser (#1) sofort an den Text zu zerlegen und danach ein komplexes Bild aufzubauen, das man doch mal anzeigen k&ouml;nnte. Zwischendurch werden immer mal wieder weitere, fehlende Daten bemerkt (steht ja im String) und von #2 abgeholt (hier kann man den ganzen Teil bis hierher noch 1-2x wiederholen, dazu noch einige dutzend Durchl&auml;ufe mit weniger Umfang, z.b. weil #2 feststellt dass #3 nicht ben&ouml;tigt wird und nur eine Datei von der Festplatte liest und zur&uuml;ckgibt.).</p>
<p>Das dauert jetzt nat&uuml;rlich etwas, aber dennoch: irgendwann steht das Bild und auch eine Verwaltungsstruktur die die Daten des HTML-Dokumentes, diverser CSS-Daten und was wei&szlig; ich noch alles enth&auml;llt, liegt auch bereits im RAM.<br/>Meistens werden w&auml;hrend dieses Aufbaus, weitere Substrings dieser Dokumente durch einen Parser gejagt und mit Daten der Verwaltungsstruktur gef&uuml;ttert. Nein, eigentlich sind es eher verschiedene Parser, f&uuml;r verschiedenste Arten von Daten.</p>
<p>Wir h&auml;tten da z.B. reine, statische Definitionen wie welcher Teil des Bildes aussehen soll (und hier f&auml;ngt der Browser an wild nach den passenden Elementen im Baum zu suchen, diese umzugestallten, Kindelemente mit bestimmten Eigenschaften zu versehen, ... kurz: das Bild wird v&ouml;llig umgebaut)<br/>Andere Teile enthalten Befehle was der Browser jetzt schon wieder ganz tolles und interaktives tun soll. Animationen darstellen (mehrfach hintereinander das Bild ausgeben, umbauen und wieder ausgeben), Werte im Baum &auml;ndern (und nat&uuml;rlich das Bild entsprechend umbauen) oder auch einfach nur ein paar weitere Anfragen an den Server senden, er soll doch bitte noch weitere Inhalte von irgendwelchen Adressen liefern (und wieder Strings die zusammengestellt und abgesendet werden).<br/>Gerne produzieren diese letzteren Inhalte auch weitere, die genau wie sie selbst aussehen, irgendwo mit der Verwaltungsstruktur verkn&uuml;pft werden und zu anderen Zeitpunkten dann wieder vom Parser ausgef&uuml;hrt werden m&uuml;ssen.</p>
<p>Weil das nat&uuml;rlich alles noch viel zu langweilig w&auml;re, gibt es nat&uuml;rlich noch jede Menge weitere Inhaltstypen, f&uuml;r die #1 Bl&ouml;cke im Bild frei h&auml;lt und die dort von wieder anderen Programmen dargestellt werden, die mit bereits an #1 angeh&auml;ngte Erweiterungen weitergeleitet werden (meistens auch wieder Strings oder Bin&auml;rdaten die an interpretierte Sachen von der Festplatte des Rechners gegeben werden) oder auch ab und zu Sachen, die komplett von #1 unabh&auml;ngige Programme auf dem Rechner starten.</p>
<p>Ich hab hier zwischendrin irgendwann den &Uuml;berblick verloren, wann wie oft Daten als String &uuml;bertragen wurden und wie oft welcher String umst&auml;ndlich geparst wurde, auch Festplatten und Zwischenspeicher werden weit mehr als genug belastet. Eines ist mir jedoch mehr als klar:<br/>Dieser ganze Prozess ist v&ouml;llig im Eimer! Die eigentliche Grundfunktion von HTTP ist nunmal Dateien aus einem entferntem Dateisystem abzurufen. HTML ist dann nur ein Dateityp, der urspr&uuml;nglich mal Informationen in einem Textdokument &uuml;bersichtlicher darstellen sollte, WIE die Darstellung erfolgt sollte dabei weitestgehend dem Browser &uuml;berlassen bleiben.</p>
<p>Was das alles mit interaktiven Inhalten und Interaktionen mit anderen Clients &uuml;ber einen zentralen Server zu tun haben sollte, warum wir permanent ein Bild neu aufbauen, statt einfach Zeichenfunktionen bereitzustellen, warum wir HTML so verbiegen und erweitern bis wir pixelgenau Bilder damit auf jedem Bildschirm gleich anzeigen k&ouml;nnen, warum wir f&uuml;r jedes von hunderten Bildern auf der Seite eine neue Verbindung aufmachen, warum wir denken dass alle 1-5 minuten nachzufragen ob sich was ge&auml;ndert hat w&auml;re eine gute Methode um aktuelle Daten zu haben, warum wir permanent von Programmen Texte parsen lassen die gerade Programme erstellt haben, warum wir "Sitzungen" &uuml;ber hunderte Verbindungsaufbauten und Datei&uuml;bertragungen hinweg zusammenzufassen versuchen...</p>
<p>...ja, alle das und noch viel mehr bleibt mir v&ouml;llig unklar. Nein! Eigentlich ist das schon wieder gelogen, denn der Grund ist klar: das sind alles Altlasten und Produkte von Situationen in denen es einfacher war ein ungeeignetes Werkzeug anzupassen bis es gerade so funktioniert statt ein neues Werkzeug zu erfinden.<br/>Die einzigen unbeantworteten Fragen sind eigentlich: "Warum scheint das au&szlig;er mir keiner zu bemerken?" und "Wann sind wir endlich an dem Punkt, da unser permanent verbogenes Werkzeug endlich mal nicht mehr genug biegsam ist und endlich keine Wahl mehr bleibt als etwas sinnvolles zu bauen?"<br/></p>
